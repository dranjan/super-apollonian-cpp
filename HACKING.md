# Implementation Notes

## The Math

Mathematically, nothing here is complicated. If you've studied basic
complex analysis, you can understand everything going on. Specifically,
you should know about:

- the Riemann sphere,
- M&ouml;bius transformations (a.k.a. linear fractional
  transformations), and
- the concept of a group and group actions.

We won't go into a full discourse on the theory here, but here's a
concise mathematical description of the image being drawn. This isn't
meant to be a complete definition, but it may help provide context
when reading the code.

- The image area is modeled mathematically as a rectangular region on
  the complex plane.

- The image is comprised of a finite collection of *generalized disks*,
  where a generalized disk is one of:
  1. a circle and its interior (a proper disk),
  2. a circle and its exterior (a disk complement), or
  3. a line in the plane and one of the half-planes bounded by it.

  (Note that on the Riemann sphere, all of these are just "disks,"
  and the distinction above only comes about by considering whether the
  extra point at infinity respectively falls outside, inside, or on the
  boundary of the disk.)

- The disks are generated mathematically by a simple rule, that the
  collection of disks must be closed under the action of a specific
  discrete group of M&ouml;bius transformations, i.e., a *Kleinian
  group*. (Note that the image or preimage of a generalized disk under a
  M&ouml;bius transformation is always a generalized disk, with no
  exceptions.) This group is infinite, and the resulting set of disks
  is also infinite, but any disks that are smaller than a tunable
  threshold, or that can be proved not to intersect the bounded viewing
  rectangle, are pruned, resulting in a finite set.

- As a small asterisk on the above, the group can swap the inside and
  outside of any one of these disks, but we only draw either one or
  the other, almost always the inside. This also helps ensure that the
  pruning described above always terminates with a finite set.

- The color assigned to a disk is determined as follows.
  1. Four separate `(red, green, blue)`
     color triples are chosen up front, which can be
     arbitrary. To slightly abuse
     an art term, these can be called the "primary colors" of the
     rendering.
  2. We want to assign primary colors to the disks in such a way that all
     four colors are used, and such that the symmetry group of the fractal
     permutes the colors in a well defined way. It can be shown that there
     is a unique way to do this, up to permutation of the colors. Thus,
     we assign the four colors to some starting configuration of four disks,
     which determines the rest of the colors. (Any configuration of four
     mutually tangent disks always uses all four colors, which is useful
     here.)
  3. Each point on the plane can now be assigned an RGB color in a
     pretty natural way: for each disk containing the point,
     add its primary color from step 2, scaled by a geometry-dependent
     factor to ensure that very small disks have minor
     contributions. The extra factor is necessary to have a basic sense
     of continuity and make the image visually parseable.

     A final filter may optionally be applied if necessary
     to bring the resulting RGB triple back into the unit cube.

That's only a general outline and leaves many details unspecified.
To understand it fully, I recommend skimming the code. The pure math
part of it, i.e., what is described above, is not overly technical or
obfuscated.

## The Algorithm

The math described above is essentially implemented directly. A few points
may be worthy of note.

### Generating the Group

To generate the disks being drawn, we begin with a single disk chosen
up front and then generate elements from the Kleinian group and apply
them to the chosen disk. This Kleinian group is finitely generated and
is in fact an *automatic group*, meaning that it can be generated by
enumerating finite paths on a specific directed graph.
The graph we need for this particular group is
extremely simple, making this a pretty attractive technique.

### Recursion

Enumerating paths on a graph is a simple graph traversal problem
that is very natural to express recursively. However, the particular geometry
of this fractal forces us to visit a lot of extremely long paths,
so making a recursive call for each edge is dangerous and likely to cause
call stack overflow. This is easily worked around by explicitly using a
stack data structure in a single loop in lieu of the recursion.

### Multithreading

This algorithm is very amenable to parallel processing, and there are a
few different ways to approach it.  Here, we parallelize the rendering:
the image array is subdivided into subimages, and each is rendered
independently in a separate thread. This means some of the computation
near the root of the computation tree needs to be repeated in each
thread, but the vast majority of the work is done near the leaves of the
tree, so this is still an effective strategy, and the synchronization
between threads is very minimal.

## Aesthetics

### Color Accumulation

If you try to implement the general mathematical description given above,
you may encounter one fundamental difficulty. There are many points where
many circles are mutually tangent. To be more precise, these are points
where *infinitely many* circles would be tangent if we were to apply the
whole infinite group, and these points are *dense* in the plane.
The circles tangent to any one of these points are generally
visited on two completely separate branches of the computation tree.
Thus, without some care, it's likely to get the disks converging to any
of these points to converge to two distinct colors. This isn't a deal breaker
by any means, but I did want to avoid this for purely aesthetic reasons.

The solution adopted here is beautifully simple and stupid: we just make
the color always converge to white at these points. This is not the only
way to accomplish that goal, but it strikes a pretty good balance between
the aesthetic goal and implementation simplicity.

If you've been following this whole discussion, though, you might have an
objection here: since these points of tangency are dense in the plane and
all of them are the same color (white), that means a "mathematically perfect"
rendering of this fractal would just be a white image!
We can simply acknowledge that fact here, and I argue that
this is a case where stopping just short of mathematical perfection seems
to give really good results. Sometimes accepting, and even embracing,
imperfection is a sound artistic choice.

### Perfect Circles

If pixels were microscopic, the result would look fine no matter how exactly
we chose to paint the interiors of generalized disks, but that's not the
case on displays available today. Thus, how we model pixels and the
contributions of disks to the pixels they touch can have a large effect
on the quality of the result.

The disk rendering should have three basic properties.

1. The boundary circle of a disk should appear *sharp*, meaning there
   should be as abrupt a transition from the interior to the exterior
   as possible when crossing the boundary circle.
2. The boundary circle of a disk should appear *smooth*, meaning
   it should actually look like a perfect circle and not a series of
   line segments or something else.
3. Because of the situation described above with many circles mutually
   tangent at specific points, repeatedly repainting the same pixels
   for many disks should not introduce image artifacts.

The first two properties are fundamental to vector graphics, while
the third property is pretty specific to this fractal. There are
some inherent tradeoffs here, like between sharpness and smoothness,
but with care, it is possible to satisfy all three properties.
Without a full explanation, here's a working approach.

To each pixel, we associate a *point spread function* (PSF), which is
any probability density that is reasonably well localized around the
pixel's center. (To get more sharpness, concentrate more mass near the
center, and to get more smoothness, spread the mass around more.)
For each disk being imaged, take its color contribution, scale it by
the total mass of any pixel's PSF contained in the disk, and add it to
that pixel's color value. Repeat this for all pixels that intersect the
generalized disk, which can be enumerated efficiently.

Note that we say to *add* the color value here
and not to *replace* the pixel's value,
and this is crucial in order to satisfy the third
basic property described above, that repeatedly repainting pixels
many times should not introduce artifacts.
We won't give a rigorous proof, but the idea is that when the colors
are always accumulated additively, the result of the computation
described above is mathematically equivalent to rendering the image
first in infinite resolution and then applying all the pixel PSFs to
get the finite-resolution image.
(Technically that's only true in exact arithmetic, and floating-point
arithmetic will accumulate roundoff, but using double precision
largely removes that concern here.) This may seem pedantic,
but it really makes a noticeable difference in the output
image.

This fractal has a specific property that makes it easier
to convert a pixel-replacing algorithm to a pixel-adding one, namely that
any two disks being drawn either have disjoint interiors, or one
contains the other. That means that as long as the containing disk is
imaged first, the smaller disk's replacement color can be converted to
an additive color by simply subtracting the containing disk's color.
There is a small extra bookkeeping cost, since we need to keep track
of the immediate containing disk of every disk, but this is straightforward
in the graph traversal scheme described earlier.

That all leaves one unspecified parameter: the shape of the PSF.
Note that in photogrammetry and physically-based rendering, a choice of
PSF can be more or less correct based on how accurately it models what
real hardware does, but since there's no concern of photorealism here,
we as artists are free to choose a PSF that fits best with our goals.
In my opinion, there are two really good choices. The first is to
make the PSFs be uniform distributions on little squares, so that
the pixels' PSFs' supports all neatly tile the image region.
In practice, this achieves very good sharpness and smoothness.
Alternatively, we could use little disks that are approximately
the same size as those little squares, which will trade either
a little sharpness or smoothness or both (depending on the exact size
of those disks) but leads to a simpler implementation than
square PSFs.

Since the square PSFs still aren't difficult to implement, this
implementation uses that, but circular PSFs are a perfectly
valid alternative and can still lead to an excellent result.

## The Code

In my opinion the code quality in this implementation is "decent."
Experienced programmers are likely to notice some significant quality
issues, like lack of automated tests and poor encapsulation.
I think it wouldn't be too hard to address those, but since the code
has largely done its computational job at this point and I do think it's
not too hard to follow in spite of those issues, I currently have no
plans to do any major work to address them. However, if the code needs
to be repurposed or built on in the future, I would revisit that
position.
